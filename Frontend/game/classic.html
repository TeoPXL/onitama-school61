<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test</title>

    <link rel="icon" type="image/webp" sizes="16x16" href="../files/icons/icon-16.webp">
    <link rel="icon" type="image/webp" sizes="32x32" href="../files/icons/icon-32.webp">
    <link rel="icon" type="image/webp" sizes="64x64" href="../files/icons/icon-64.webp.png">
    <link rel="icon" type="image/webp" sizes="128x128" href="../files/icons/icon-128.webp">
    <link rel="icon" type="image/webp" sizes="512x512" href="../files/icons/icon-512.webp">
    <!-- iOS -->
    <link rel="apple-touch-icon" sizes="180x180" href="../files/icons/icon-180.webp">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../files/css/main.css">
    <style>
        .main {
            position: fixed;
            top: 0;
            left: 0;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            padding: 0;
            background: var(--color-background-gradient);
            display: flex;
            flex-flow: column;
            gap: 10px;
            padding: 10px;
            justify-content: center;
            align-items: center;
            max-width: unset;
        }
        #container {
            width: 100%;
            height: 60%;
            position: relative;
            border-radius: 1em;
            overflow: hidden;
            position: relative;
            max-width: 700px;
            max-height: 700px;
        }
        .game-controls {
            background: var(--color-background-fade);
            width: 100%;
            height: 100%;
            border-radius: 1em;
            max-width: 700px;
            max-height: 700px;
            display: flex;
            flex-flow: column;
        }
        .game-buttons {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }
        .game-button {
            padding: 3px;
            padding-left: 12px;
            padding-right: 12px;
            background: var(--color-main);
            color: var(--color-background);
            border-radius: 2em;
            margin-top: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: 0.2s;
        }
        .game-button-hidden {
            display: none;
        }
        .game-button:hover {
            filter: brightness(0.5);
        }
        .game-cards {
            height: calc(100% - 20px);
            width: calc(100% - 20px);
            margin-left: 10px;
            margin-bottom: 10px;
            overflow: hidden;
            display: flex;
            flex-flow: column;
            gap: 15px;
            overflow-x: hidden;
        }
        .game-cards-info-list {
            width: 300%;
            height: 100%;
            display: flex;
            transition: 0.5s;
            position: relative;
        }
        .list-show-1 {
            transform: translateX(0);
        }
        .list-show-2 {
            transform: translateX(-33.333%);
        }
        .list-show-3 {
            transform: translateX(-66.666%);
        }
        .list-button-right {
            position: absolute;
            right: 66.66%;
        }
        .list-button-left {
            position: absolute;
            left: -5px;
        }
        .list-button i {
            height: 25px;
            justify-content: center;
            align-items: center;
        }
        .list-button svg {
            width: 40px;
            height: 40px;
        }
        .game-cards-info {
            height: 100%;
            width: 100%;
            text-align: center;  
            display: flex;
            flex-flow: column;
        }
        .game-cards-name {
            margin-bottom: 5px;
        }
        .game-cards-container {
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        .game-card {
            background: black;
            border-radius: 1em;
            width: 32%;
            margin-left: 0.5%;
            margin-right: 0.5%;
            height: 100%;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .container-loading::after {
            content: 'Loading...';
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000bd;
            justify-content: center;
            align-items: center;
            font-size: 150%;
            font-weight: 500;
            backdrop-filter: blur(5px);
            text-align: center;
        }
        .loading {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            transform: translateX(-100%);
            background-image: linear-gradient(90deg, rgba(255, 255, 255, 0) 0, rgba(55, 55, 55, 0.2) 25%, rgba(40, 40, 40, 0.2) 75%, rgba(255, 255, 255, 0));
            animation: shimmer 2s infinite;
            animation-timing-function: cubic-bezier;
            content: '';
        }
        .container-2-1::after {
            content: '(1/2) - Waiting for other players...';
        }
        .container-2-2::after {
            content: '(2/2) - The table is full...';
        }
        .container-4-1::after {
            content: '(1/4) - Waiting for other players...';
        }
        .container-4-2::after {
            content: '(2/4) - Waiting for other players...';
        }
        .container-4-3::after {
            content: '(3/4) - Waiting for other players...';
        }
        .container-4-4::after {
            content: '(4/4) - The table is full...';
        }
        .container-waiting::after {
            content: 'Almost ready! Waiting for the owner to start the game...';
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #00000095;
            justify-content: center;
            align-items: center;
            font-size: 150%;
            font-weight: 500;
            backdrop-filter: blur(5px);
            text-align: center;
        }
        @keyframes shimmer {
            100% {
                transform: translateX(100%);
            }
        }
        .floating-error {
            z-index: 3;
        }
        @media screen and (min-width: 600px) {
            .main {
                flex-flow: row;
            }
            #container {
                height: 100%;
            }
        }
        @media screen and (min-width: 750px) {
            #container {
                
            }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.163.0/build/three.module.js"
            }
        }
    </script>
</head>

<body>
    <div class="floating-error floating-error-hidden">
        <div class="floating-error-title">Error: 401</div>
        <div class="floating-error-subtitle">Subtitle text</div>
        <div class="floating-error-button">Dismiss</div>
    </div>
    <div style="display: none;" class="jump">Click me1</div>
    <div style="display: none;" class="attack">Click me2</div>
    <main class="main">
    <div id="container" class="container-loading">



        <script src="../files/js/shared.js"></script>
        <script type="module">
            import * as THREE from 'three';
            import { GLTFLoader } from 'https://unpkg.com/three@0.163.0/examples/jsm/loaders/GLTFLoader.js';
            import { OrbitControls } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/OrbitControls.js';
            const players = [
                    {
                        "name": "Testuser",
                        "color": 0x13F287,
                        "facing": 1,
                        "ninja": ["default", "jump_flip", "attack_god"],
                        "master": ["default", "default", "default"]
                    },
                    {
                        "name": "Anotheruser",
                        "color": 0xff0000,
                        "facing": 0,
                        "ninja": ["default", "default", "attack_spin"],
                        "master": ["default", "default", "default"]
                    },
                ];
            const cards = [
                {
                    "name": "cat",
                    "moves": [[1, 0], [1, 1], 0, 2]
                }
            ];
            const currentTableId = localStorage.getItem('tableId');
            let currentPlayer;
            let gameId;
            let gameStarted = false;

            class Game {
                constructor(playercount){
                    //console.log(this.team1, this.team2);
                    if(playercount > 2){
                        this._board = new Board(7);
                    } else {
                        this._board = new Board(5);
                    }

                    //Initialize game world
                    this._scene = new THREE.Scene();
                    this._raycaster = new THREE.Raycaster();
                    this.raycaster.params.Points.threshold = 0.1; 
                    this.raycaster.params.Line.threshold = 0.1; 
                    this._clock = new THREE.Clock();
                    //console.log(this._clock);
                    this._mouse = new THREE.Vector2();
                    this.scene.background = new THREE.Color(0x87ceeb);
                    this.containerWidth = document.getElementById("container").clientWidth;
                    this.containerHeight = document.getElementById("container").clientHeight;
                    this._camera = new THREE.PerspectiveCamera(75, this.containerWidth / this.containerHeight, 0.1, 1000);
                    this._renderer = new THREE.WebGLRenderer({ antialias: true });
                    const onWindowResize = () => {
                        // Update container dimensions
                        const containerWidth = document.getElementById("container").clientWidth;
                        const containerHeight = document.getElementById("container").clientHeight;

                        // Update camera aspect ratio
                        this._camera.aspect = containerWidth / containerHeight;
                        this._camera.updateProjectionMatrix();

                        // Update renderer size
                        this._renderer.setSize(containerWidth, containerHeight);
                        this.camera.fov = 60;
                        this.camera.updateProjectionMatrix();
                    };

                    // Add event listener for window resize
                    window.addEventListener('resize', onWindowResize);

                    // Call onWindowResize initially to set up the correct dimensions
                    onWindowResize();
                    this.pixelRatio = window.devicePixelRatio || 1; // Get device pixel ratio
                    this.renderer.setPixelRatio(this.pixelRatio);
                    this.renderer.setSize(this.containerWidth, this.containerHeight, false);
                    this.ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                    this.scene.add(this.ambientLight);
                    this.sunColor = 0xF7EACD; // A warm, yellowish-orange color (Like the sun)
                    this.sunLight = new THREE.PointLight(this.sunColor, 60, 0, 1);
                    this.sunLight.position.set(10, 10, 0);
                    this.scene.add(this.sunLight);
                    document.getElementById('container').appendChild(this.renderer.domElement);

                    this._controls = new OrbitControls(  
                        this.camera, 
                        this.renderer.domElement
                    );
                    this.controls.enableDamping = true; 
                    this.controls.dampingFactor = 0.2;

                    this.controls.screenSpacePanning = false;
                    this.controls.enablePan = false;

                    this.controls.minDistance = 6;
                    this.controls.maxDistance = 16;

                    this.controls.maxPolarAngle = Math.PI / 2.25;
                    this.controls.target.z = -0;

                    this.loader = new GLTFLoader();
                    const self = this;
                    this.loader.load('assets/board.gltf', function (gltf) {
                        self.boardObject = gltf.scene;
                        self.boardObject.rotation.y = 1.5708;
                        self.boardObject.position.y = -0.15;
                        self.scene.add(gltf.scene);  

                    }, undefined, function (error) {
                        console.error(error);
                    });

                    this.camera.position.z = -12;
                    this.camera.position.y = 4.5;
                    this.camera.rotation.x = -0.5;

                    //this.fillModels();
                    animate();
                }

                get clock(){
                    return this._clock;
                }
                set clock(clock){
                    this._clock = clock;
                }
                get board(){
                    return this._board;
                }
                set board(board){
                    this._board = board;
                }
                get controls(){
                    return this._controls;
                }
                set controls(controls){
                    this._controls = controls;
                }
                get renderer(){
                    return this._renderer;
                }
                set renderer(renderer){
                    this._renderer = renderer;
                }
                get scene(){
                    return this._scene;
                }
                set scene(scene){
                    this._scene = scene;
                }
                get camera(){
                    return this._camera;
                }
                set camera(camera){
                    this._camera = camera;
                }
                get raycaster(){
                    return this._raycaster;
                }
                set raycaster(raycaster){
                    this._raycaster = raycaster;
                }
                get mouse(){
                    return this._mouse;
                }
                set mouse(mouse){
                    this._mouse = mouse;
                }

                fillModels(){
                    for (let i = 0; i < this.board.currentBoard.length; i++) {
                        for (let k = 0; k < this.board.currentBoard[i].length; k++) {
                            const id = this.board.currentBoard[i][k][0];
                            const type = this.board.currentBoard[i][k][1];
                            let coord = [i, k];
                            if (id < 6){
                                this.placeObject(this.team1, coord, id, type);
                            } else if (id < 11) {
                                this.placeObject(this.team2, coord, id, type);
                            } else if (id < 16) {
                                this.placeObject(this.team3, coord, id, type);
                            } else if (id < 21) {
                                this.placeObject(this.team4, coord, id, type);
                            }
                            
                        }
                    }
                }

                placeObject(team, coord, identity, type){
                    console.log("placing object")
                    if(identity == 0){
                        console.log("Identity: 0")
                        let material = new THREE.MeshBasicMaterial({
                            color: 0xffffff,
                            transparent: true, // Make it transparent
                            opacity: 0.1, // Set the opacity (0 is fully transparent, 1 is fully opaque)
                        });

                        let cubeGeometry = new THREE.BoxGeometry(1.25, 0.05, 1.25);

                        // Create a mesh using the geometry and material
                        let cube = new THREE.Mesh(cubeGeometry, material);
                        cube.name = "emptyslot"+identity;
                        cube.position.x = coord[1] * 2 - 4;
                        cube.position.z = coord[0] * 2 - 4;
                        this.scene.add(cube);
                        return;
                    }

                    let asset;
                    let orient = team.facing;
                    let boxColor;
                    let ninja;
                    let master;
                    let tScale = 2;

                    if(team.color == "Green"){
                        boxColor = 0x13F287;
                        ninja = 'assets/green_ninja.gltf';
                        master = 'assets/green_master.gltf';
                    }
                    if(team.color == "Red"){
                        boxColor = 0xff0000;
                        ninja = 'assets/red_ninja.gltf';
                        master = 'assets/red_master.gltf';
                    }
                    if(team.color == "Yellow"){
                        boxColor = 0xfffb0c;
                        ninja = 'assets/yellow_ninja.gltf';
                        master = 'assets/yellow_master.gltf';
                    }
                    if(team.color == "Orange"){
                        boxColor = 0xff5c0c;
                        ninja = 'assets/orange_ninja.gltf';
                        master = 'assets/orange_master.gltf';
                    }
                    if(team.color == "Blue"){
                        boxColor = 0x0c82ff;
                        ninja = 'assets/blue_ninja.gltf';
                        master = 'assets/blue_master.gltf';
                    }

                    if(type == "k"){
                        //load master based on color!
                        asset = master;
                        orient = orient + 2;
                        tScale = 1;
                    } else {
                        //load ninja based on color!
                        asset = ninja;
                    }
                    const self = this;
                    this.loader.load(asset, function (gltf) {
                        let modelGLTF = gltf;
                        let modelObject = gltf.scene;
                        let mixer = new THREE.AnimationMixer(modelObject);
                        let action = mixer.clipAction( gltf.animations[0] );
                        self.scene.add(gltf.scene);
                        modelObject.rotation.y = orient * 1.57 * 2;
                        modelObject.position.z = coord[0] * 2 - 4;
                        modelObject.position.x = coord[1] * 2 - 4;
                        action.timeScale = tScale;
                        action.play(); 
                        //console.log(action);     

                        let material = new THREE.MeshBasicMaterial({
                            color: boxColor,
                            transparent: true, // Make it transparent
                            opacity: 0.01, // Set the opacity (0 is fully transparent, 1 is fully opaque)
                        });

                        // Create a cube geometry with dimensions 2x2x2
                        let cubeGeometry = new THREE.BoxGeometry(1.25, 0.05, 1.25);

                        // Create a mesh using the geometry and material
                        let cube = new THREE.Mesh(cubeGeometry, material);
                        cube.name = team.number + "hover"+identity;
                        modelObject.add(cube);

                        self.board.currentBoard[coord[0]][coord[1]] = [identity, type, modelObject, mixer, modelGLTF];

                    }, undefined, function (error) {
                        console.error(error);
                    });
                }
            };

            class Board {
                constructor(size){
                    switch (size) {
                        case 7:
                            this.currentBoard = [
                                [[0], [1, "p"], [2, "p"], [3, "k"], [4, "p"], [5, "p"], [0]],
                                [[11, "p"], [0], [0], [0], [0], [0], [16, "p"]],
                                [[12, "p"], [0], [0], [0], [0], [0], [17, "p"]],
                                [[13, "k"], [0], [0], [0], [0], [0], [18, "p"]],
                                [[14, "p"], [0], [0], [0], [0], [0], [19, "p"]],
                                [[15, "p"], [0], [0], [0], [0], [0], [20, "p"]],
                                [[0], [6, "p"], [7, "p"], [8, "k"], [9, "p"], [10, "p"], [0]],
                            ];
                            break;
                    
                        default:
                            this.currentBoard = [
                                [[1, "p"], [2, "p"], [3, "k"], [4, "p"], [5, "p"]],
                                [[0], [0], [0], [0], [0]],
                                [[0], [0], [0], [0], [0]],
                                [[0], [0], [0], [0], [0]],
                                [[6, "p"], [7, "p"], [8, "k"], [9, "p"], [10, "p"]],
                            ];
                            break;
                    }
                }

                get board(){
                    return this.board;
                }
            }

            var game = new Game(2);

            const loadingDivElement = document.createElement('div');
            loadingDivElement.className = 'loading';
            document.getElementById('container').appendChild(loadingDivElement);

            window.addEventListener('load', () => {
                document.querySelector('.jump').addEventListener('click', () => {
                    giveAnimation("jump");
                });
                document.querySelector('.attack').addEventListener('click', () => {
                    giveAnimation("attack");
                });
            });

            function giveAnimation(type) {
                const board = game.board;
                for (let i = 0; i < board.currentBoard.length; i++) {
                    for (let k = 0; k < board.currentBoard.length; k++) {
                        const el = board.currentBoard[i][k][3];
                        if(board.currentBoard[i][k][0] == 0){

                        } else if (el != undefined) {
                            try {
                                let mixer = board.currentBoard[i][k][3];
                                let action;
                                if (type == "jump"){
                                    action = mixer.clipAction( board.currentBoard[i][k][4].animations[1] );
                                } else {
                                    action = mixer.clipAction( board.currentBoard[i][k][4].animations[3] );
                                }
                                
                                mixer.stopAllAction();
                                action.play(); 
                            } catch {
                                
                            }
                            
                        }
                        
                    }
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                if(game == undefined){
                    return;
                }
                const clock = game.clock;
                const board = game.board;
                const controls = game.controls;
                const renderer = game.renderer;
                let delta = clock.getDelta();
                for (let i = 0; i < board.currentBoard.length; i++) {
                    for (let k = 0; k < board.currentBoard.length; k++) {
                        const el = board.currentBoard[i][k][3];
                        if(board.currentBoard[i][k][0] == 0){

                        } else if (el != undefined) {
                            el.update( delta );
                        }
                        
                    }
                }
                controls.update();
                renderer.render(game.scene, game.camera);
            }

            function onPointerMove(event) {
                if (game === undefined) {
                    return;
                }

                // Get the pointer coordinates in screen space
                let pointerX, pointerY;
                if (event.type.startsWith('touch')) {
                    // For touch events, get the coordinates of the first touch point
                    pointerX = event.touches[0].clientX;
                    pointerY = event.touches[0].clientY;
                } else {
                    // For mouse events, use clientX and clientY directly
                    pointerX = event.clientX;
                    pointerY = event.clientY;
                }

                // Set the mouse coordinates in the game object
                game.mouseX = pointerX;
                game.mouseY = pointerY;

                // Get the bounding rectangle of the renderer element
                let rect = game.renderer.domElement.getBoundingClientRect();

                // Calculate the mouse coordinates relative to the renderer element
                let x = (game.mouseX - rect.left) / rect.width * 2 - 1;
                let y = -(game.mouseY - rect.top) / rect.height * 2 + 1;

                // Update the mouse vector
                game.mouse.set(x, y);
                
                // update the picking ray with the camera and mouse position
                game.raycaster.setFromCamera(game.mouse, game.camera);

                // Reset previously highlighted objects
                resetHighlightedObjects();

                // calculate objects intersecting the picking ray
                let intersects = game.raycaster.intersectObjects(game.scene.children);

                let cubes = 0;
                if (intersects.length > 0) {
                    intersects.forEach(element => {
                        let object = element.object;
                        if(object.name.includes(currentPlayer+"hover")){
                            object.material.opacity = 0.8;
                            cubes++;
                        }
                    });
                }
            }

            function resetHighlightedObjects() {
                // Reset opacity for all objects with the name "hover"
                game.scene.traverse(function(child) {
                    if (child instanceof THREE.Mesh && child.name.includes("hover")) {
                        child.material.opacity = 0.3; // Reset opacity to default
                        child.material.needsUpdate = true; // Update material
                    }
                });
            }

            // Add event listeners for pointer and touch events
            window.addEventListener('pointermove', onPointerMove, false);
            window.addEventListener('touchmove', onPointerMove, false);
            window.addEventListener('touchstart', onPointerMove, false);
            window.addEventListener('touchend', resetHighlightedObjects, false);

            async function fetchTable(){
                if(gameStarted == true){
                    return;
                }
                const response = await fetch(currentApi + "/api/Tables/" + currentTableId, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    }
                }).then(response => {
                    if (!response.ok) {
                        return response.json().then(errorData => {
                            throw_floating_error(errorData.message, '500', "#c60025");
                        });
                    }
                    return response.json();
                }).then(data => {
                    //console.log(data);

                    const table = data;
                    if(currentPlayer == undefined){
                        //console.log("Not undefined");
                        const className = "container-"+table.preferences.numberOfPlayers+"-"+table.seatedPlayers.length;
                        console.log(className);
                        document.getElementById('container').classList.add(className);
                        if(data.hasAvailableSeat != true){
                            //The table is full, do stuff
                            document.getElementById('container').classList.remove('container-loading');
                            document.getElementById('container').classList.add('container-waiting');
                            //Set team1, 2, (3 and 4) as players in order, or by direction.
                            for (let i = 0; i < data.seatedPlayers.length; i++) {
                                const player = data.seatedPlayers[i];
                                if(player.direction == "North"){
                                    player.facing = 1;
                                    player.number = 1;
                                    game.team1 = player;
                                    if(user.id == player.id){
                                        currentPlayer = 1;
                                    }
                                } else if (player.direction == "South"){
                                    player.facing = 0;
                                    player.number = 2;
                                    game.team2 = player;
                                    if(user.id == player.id){
                                        currentPlayer = 2;
                                        game.camera.position.set(0, 4.5, 12); // Move the camera along the negative z-axis
                                        game.camera.lookAt(0, 0, 0); // Look back towards the origin

                                        // Update OrbitControls to reflect changes
                                        game.controls.update();

                                    }
                                }
                            }
                            //Orient game camera so that the player sees his team in front
                            if(currentPlayer == 1){
                                //Orient camera
                            } else if (currentPlayer == 2){
                                //Orient camera for player 2
                            }
                            //Maybe set limits for cam rotation?
                            //fill the models based on team color
                            console.log("filling models");
                            game.fillModels();
                            //Make sure the current player can only control his own pawns, and only when it is his turn.
                            //Move this to its own function
                        }

                    setTimeout(fetchTable, 500);
                    } else if(gameId == undefined || gameId == "00000000-0000-0000-0000-000000000000") {

                        gameId = table.gameId;
                        console.log(gameId);
                        setTimeout(fetchTable, 500);
                    } else {
                        startGame();
                        console.log(gameId);
                    }
                    //setTimeout(fetchTable, 2500);
                }).catch(error => {
                    console.log(error);
                    throw_floating_error(error, '500', "#c60025");
                });
            }
            window.fetchTable = fetchTable;

            async function startGame(){
                gameStarted = true;
                document.getElementById('container').classList.remove('container-waiting');
                document.querySelector('.loading').remove();
                document.querySelector('.game-button-start').classList.add('game-button-hidden');
            }
            window.startGame = startGame;
        </script>
    </div>
    <div class="game-controls">
        <div class="game-buttons">
            <div class="game-button game-button-start">Start game</div>
        </div>
        <div class="game-cards">
            <div class="game-cards-info-list">
                <div class="game-cards-info">
                    <div class="game-cards-name">Playername:</div>
                    <div class="game-cards-container">
                        <div class="game-card"></div>
                        <div class="game-card"></div>
                        <div class="game-card game-card-extra"></div>
                    </div>
                </div>

                <div class="game-cards-info">
                    <div class="game-cards-name">Playername:</div>
                    <div class="game-cards-container">
                        <div class="game-card"></div>
                        <div class="game-card"></div>
                        <div class="game-card game-card-extra"></div>
                    </div>
                </div>

                <div class="game-cards-info">
                    <div class="game-cards-name">Playername:</div>
                    <div class="game-cards-container">
                        <div class="game-card"></div>
                        <div class="game-card"></div>
                        <div class="game-card game-card-extra"></div>
                    </div>
                </div>

                <div class="list-button list-button-left"><i>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5"/>
                    </svg>
                </i></div>
                <div class="list-button list-button-right"><i>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M4 8a.5.5 0 0 1 .5-.5h5.793L8.146 5.354a.5.5 0 1 1 .708-.708l3 3a.5.5 0 0 1 0 .708l-3 3a.5.5 0 0 1-.708-.708L10.293 8.5H4.5A.5.5 0 0 1 4 8"/>
                    </svg>
                </i></div>
            </div>
            
            <div class="game-cards-info">
                <div class="game-cards-name game-cards-you">You:</div>
                <div class="game-cards-container">
                    <div class="game-card"></div>
                    <div class="game-card"></div>
                    <div class="game-card game-card-extra"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        document.querySelector('.game-button-start').addEventListener('click', async () => {
            const currentTableId = localStorage.getItem('tableId');
            const response = await fetch(currentApi + "/api/Tables/" + currentTableId + "/start-game", {
                    method: 'POST',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({ })
                }).then(response => {
                    if (!response.ok) {
                        return response.json().then(errorData => {
                            throw_floating_error(errorData.message, '400', "#c60025");
                        });
                    } else {
                        startGame();
                    }
                    return response.json();
                }).then(data => {
                }).catch(error => {
                    console.log(error);
                    throw_floating_error(error, '500', "#c60025");
                });
        })
    </script>
    </main>
</body>

</html>